class Solution {
  public:
    string findOrder(vector<string> &words) {

        int n = words.size();
        string ans;
        vector<pair<char,char>> p;

        // -------- FIX 1: correct comparison loop --------
        for(int i = 0; i < n - 1; i++){
            string word1 = words[i];
            string word2 = words[i + 1];
            int m1 = word1.length();
            int n1 = word2.length();

            int j = 0;
            while(j < m1 && j < n1){
                if(word1[j] != word2[j]){
                    p.push_back({word1[j], word2[j]});
                    break;
                }
                j++;
            }

            // -------- FIX 2: prefix invalid case --------
            if(j == n1 && m1 > n1){
                return "";
            }
        }

        vector<bool> present(26, false);
        vector<int> indegree(26, 0);
        vector<vector<int>> list(26);

        for(auto &w : words){
            for(char c : w){
                present[c - 'a'] = true;
            }
        }

        // build graph
        for(auto it : p){
            int u = it.first - 'a';
            int v = it.second - 'a';
            list[u].push_back(v);
            indegree[v]++;
        }

        // Kahn's algorithm
        queue<int> q;
        for(int i = 0; i < 26; i++){
            if(present[i] && indegree[i] == 0){
                q.push(i);
            }
        }

        while(!q.empty()){
            int node = q.front();
            q.pop();
            ans.push_back(char(node + 'a'));

            // -------- FIX 3: correct indegree update --------
            for(int v : list[node]){
                indegree[v]--;
                if(indegree[v] == 0){
                    q.push(v);
                }
            }
        }

        int cnt = 0;
        for(int i = 0; i < 26; i++){
            if(present[i]) cnt++;
        }

        if(ans.length() == cnt)
            return ans;
        else
            return "";
    }
};
